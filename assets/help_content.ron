// assets/help_content.ron
(
    // This section describes the general layout and workflow of the application.
    general_help: (
        title: "LC-3 Emulator & Toolkit",
        description: "This tool allows you to write, compile, execute, and debug LC-3 assembly programs. The workspace consists of a fixed layout of panes, each designed for a specific task.",
        topics: [
            (
                title: "Understanding the Workspace",
                content: [
                    sub_heading("Editor Pane (Top-Left)"),
                    paragraph("Write your LC-3 assembly code here. The editor provides syntax highlighting for opcodes, registers, directives, and comments. Use the 'Compile' button to assemble your code into machine language, which loads it into the Memory Pane and prepares it for execution."),
                    
                    sub_heading("Controls Pane (Top-Right)"),
                    paragraph("Manage the emulator's execution state:"),
                    list_item("‚ñ∂ Run / ‚è∏ Pause: Start or stop the continuous execution of the program."),
                    list_item("‚û° Step: Execute one full LC-3 instruction, from Fetch to Store Result."),
                    list_item("‚§µ Micro Step: Execute a single phase of the CPU's instruction cycle (e.g., just the Fetch phase) for fine-grained debugging."),
                    list_item("üîÑ Reset Emulator State: Resets the CPU and memory to their initial state. It then attempts to reload the last successfully compiled program."),
                    list_item("Execution Speed: A slider to control how many clock cycles are simulated per UI update when running continuously."),
                    list_item("Skip OS Routines: When checked, the 'Step' and 'Micro Step' buttons will automatically execute through operating system code (addresses below x3000) until the Program Counter returns to user space."),

                    sub_heading("Terminal Pane (Bottom-Left)"),
                    paragraph("Handles all program input and output. Characters typed into the input line are sent to the emulator one by one for routines like GETC. Program output from OUT and PUTS is displayed in the text area above."),
                    
                    sub_heading("Memory Pane (Bottom-Middle)"),
                    paragraph("View the entire 65,536-word memory space. You can jump to specific addresses, edit values directly, and switch the display base between Binary, Decimal, and Hex. You can also set or clear breakpoints by clicking the circle (‚ö™/üõë) next to an address."),

                    sub_heading("CPU State Pane (Bottom-Right)"),
                    paragraph("Inspect the internal state of the LC-3 processor. The 'Registers & devices' section shows the values of all general-purpose (R0-R7) and special registers (PC, IR, MAR, MDR), condition codes (N, Z, P), and memory-mapped device registers. The 'Processor Cycle' section visualizes the current stage of the CPU's pipeline for the instruction being executed."),
                ]
            ),
            (
                title: "Registers and Flags",
                content: [
                    sub_heading("General Purpose Registers"),
                    paragraph("R0-R7: Eight general-purpose 16-bit registers for computation and data storage."),
                    sub_heading("Special Registers"),
                    list_item("PC (Program Counter): Points to the memory address of the next instruction to be fetched."),
                    list_item("IR (Instruction Register): Holds the current 16-bit instruction being executed."),
                    list_item("MAR (Memory Address Register): Holds the address for the next memory access."),
                    list_item("MDR (Memory Data Register): Holds the data being read from or written to memory."),
                    sub_heading("Condition Flags (in the PSR)"),
                    list_item("N (Negative): Set when the result of an operation that affects flags is negative."),
                    list_item("Z (Zero): Set when the result is zero."),
                    list_item("P (Positive): Set when the result is positive."),
                ]
            ),
        ],
    ),

    // This section provides a detailed, interactive breakdown of every LC-3 instruction.
    instruction_reference: (
        title: "LC-3 Instruction Reference",
        description: "Select an instruction category to explore. Adjust instruction fields to see how they affect the binary representation.",
        categories: [
            (
                title: "Arithmetic & Logic",
                instructions: [
                    ( name: "ADD", description: "Adds two values, storing the result in a register.", notes: Some("Sets condition codes N,Z,P."), formats: [ ( mode_selection_name: "Register", syntax: "ADD DR, SR1, SR2", description: "Adds SR1 and SR2.", operands: [dr, sr1, sr2], binary_layout: "Layout: 0001|DR|SR1|000|SR2", binary_segments: [(width:4,source:opcode(1)),(width:3,source:dr),(width:3,source:sr1),(width:3,source:fixed_bits(0)),(width:3,source:sr2)] ), ( mode_selection_name: "Immediate", syntax: "ADD DR, SR1, #imm5", description: "Adds SR1 and a 5-bit immediate.", operands: [dr, sr1, imm5], binary_layout: "Layout: 0001|DR|SR1|1|imm5", binary_segments: [(width:4,source:opcode(1)),(width:3,source:dr),(width:3,source:sr1),(width:1,source:fixed_bits(1)),(width:5,source:imm5)] ) ] ),
                    ( name: "AND", description: "Performs a bitwise AND on two values.", notes: Some("Sets condition codes N,Z,P."), formats: [ ( mode_selection_name: "Register", syntax: "AND DR, SR1, SR2", description: "ANDs SR1 and SR2.", operands: [dr, sr1, sr2], binary_layout: "Layout: 0101|DR|SR1|000|SR2", binary_segments: [(width:4,source:opcode(5)),(width:3,source:dr),(width:3,source:sr1),(width:3,source:fixed_bits(0)),(width:3,source:sr2)] ), ( mode_selection_name: "Immediate", syntax: "AND DR, SR1, #imm5", description: "ANDs SR1 and a 5-bit immediate.", operands: [dr, sr1, imm5], binary_layout: "Layout: 0101|DR|SR1|1|imm5", binary_segments: [(width:4,source:opcode(5)),(width:3,source:dr),(width:3,source:sr1),(width:1,source:fixed_bits(1)),(width:5,source:imm5)] ) ] ),
                    ( name: "NOT", description: "Performs a bitwise NOT on one value.", notes: Some("Sets condition codes N,Z,P."), formats: [ ( mode_selection_name: "Standard", syntax: "NOT DR, SR1", description: "Inverts the bits of SR1.", operands: [dr, sr1], binary_layout: "Layout: 1001|DR|SR1|111111", binary_segments: [(width:4,source:opcode(9)),(width:3,source:dr),(width:3,source:sr1),(width:6,source:fixed_bits(63))] ) ] ),
                ]
            ),
            (
                title: "Data Movement",
                instructions: [
                    ( name: "LD", description: "Loads a value from memory into a register.", notes: Some("Sets condition codes N,Z,P."), formats: [ ( mode_selection_name: "Standard", syntax: "LD DR, LABEL", description: "Loads from Mem[PC + offset9].", operands: [dr, offset9], binary_layout: "Layout: 0010|DR|PCoffset9", binary_segments: [(width:4,source:opcode(2)),(width:3,source:dr),(width:9,source:offset9)] ) ] ),
                    ( name: "LDI", description: "Loads a value from memory indirectly.", notes: Some("Sets condition codes N,Z,P."), formats: [ ( mode_selection_name: "Standard", syntax: "LDI DR, LABEL", description: "Loads from Mem[Mem[PC + offset9]].", operands: [dr, offset9], binary_layout: "Layout: 1010|DR|PCoffset9", binary_segments: [(width:4,source:opcode(10)),(width:3,source:dr),(width:9,source:offset9)] ) ] ),
                    ( name: "LDR", description: "Loads a value from a register-based address.", notes: Some("Sets condition codes N,Z,P."), formats: [ ( mode_selection_name: "Standard", syntax: "LDR DR, BaseR, #offset6", description: "Loads from Mem[BaseR + offset6].", operands: [dr, base_r, offset6], binary_layout: "Layout: 0110|DR|BaseR|offset6", binary_segments: [(width:4,source:opcode(6)),(width:3,source:dr),(width:3,source:base_r),(width:6,source:offset6)] ) ] ),
                    ( name: "LEA", description: "Loads an effective address into a register.", notes: Some("Sets condition codes N,Z,P."), formats: [ ( mode_selection_name: "Standard", syntax: "LEA DR, LABEL", description: "Loads the address (PC + offset9).", operands: [dr, offset9], binary_layout: "Layout: 1110|DR|PCoffset9", binary_segments: [(width:4,source:opcode(14)),(width:3,source:dr),(width:9,source:offset9)] ) ] ),
                    ( name: "ST", description: "Stores a register value into memory.", notes: None, formats: [ ( mode_selection_name: "Standard", syntax: "ST SR, LABEL", description: "Stores SR1 into Mem[PC + offset9].", operands: [sr1, offset9], binary_layout: "Layout: 0011|SR|PCoffset9", binary_segments: [(width:4,source:opcode(3)),(width:3,source:sr1),(width:9,source:offset9)] ) ] ),
                    ( name: "STI", description: "Stores a register value into memory indirectly.", notes: None, formats: [ ( mode_selection_name: "Standard", syntax: "STI SR, LABEL", description: "Stores SR1 into Mem[Mem[PC + offset9]].", operands: [sr1, offset9], binary_layout: "Layout: 1011|SR|PCoffset9", binary_segments: [(width:4,source:opcode(11)),(width:3,source:sr1),(width:9,source:offset9)] ) ] ),
                    ( name: "STR", description: "Stores a value to a register-based address.", notes: None, formats: [ ( mode_selection_name: "Standard", syntax: "STR SR, BaseR, #offset6", description: "Stores SR1 into Mem[BaseR + offset6].", operands: [sr1, base_r, offset6], binary_layout: "Layout: 0111|SR|BaseR|offset6", binary_segments: [(width:4,source:opcode(7)),(width:3,source:sr1),(width:3,source:base_r),(width:6,source:offset6)] ) ] ),
                ]
            ),
            (
                title: "Control Flow",
                instructions: [
                    ( name: "BR", description: "Conditionally branches based on N,Z,P flags.", notes: None, formats: [ ( mode_selection_name: "Standard", syntax: "BRnzp LABEL", description: "Jumps to PC + offset9 if any selected flag is set.", operands: [n,z,p,offset9], binary_layout: "Layout: 0000|N|Z|P|PCoffset9", binary_segments: [(width:4,source:opcode(0)),(width:1,source:n),(width:1,source:z),(width:1,source:p),(width:9,source:offset9)] ) ] ),
                    ( name: "JMP / RET", description: "Jumps to an address stored in a register.", notes: None, formats: [ ( mode_selection_name: "JMP", syntax: "JMP BaseR", description: "Sets PC to the value in BaseR.", operands: [base_r], binary_layout: "Layout: 1100|000|BaseR|000000", binary_segments: [(width:4,source:opcode(12)),(width:3,source:fixed_bits(0)),(width:3,source:base_r),(width:6,source:fixed_bits(0))] ), ( mode_selection_name: "RET", syntax: "RET", description: "Alias for JMP R7. Returns from a subroutine.", operands: [], binary_layout: "Layout: 1100|000|111|000000", binary_segments: [(width:4,source:opcode(12)),(width:3,source:fixed_bits(0)),(width:3,source:fixed_bits(7)),(width:6,source:fixed_bits(0))] ) ] ),
                    ( name: "JSR / JSRR", description: "Jumps to a subroutine, saving PC in R7.", notes: None, formats: [ ( mode_selection_name: "JSR", syntax: "JSR LABEL", description: "Jumps to PC + offset11.", operands: [offset11], binary_layout: "Layout: 0100|1|PCoffset11", binary_segments: [(width:4,source:opcode(4)),(width:1,source:fixed_bits(1)),(width:11,source:offset11)] ), ( mode_selection_name: "JSRR", syntax: "JSRR BaseR", description: "Jumps to the address in BaseR.", operands: [base_r], binary_layout: "Layout: 0100|000|BaseR|000000", binary_segments: [(width:4,source:opcode(4)),(width:3,source:fixed_bits(0)),(width:3,source:base_r),(width:6,source:fixed_bits(0))] ) ] ),
                    ( name: "TRAP", description: "Executes a system call via the trap vector table.", notes: None, formats: [ ( mode_selection_name: "Standard", syntax: "TRAP xNN", description: "Calls an OS routine. Common aliases: GETC, OUT, PUTS, IN, HALT.", operands: [trap_vect8], binary_layout: "Layout: 1111|0000|trapvect8", binary_segments: [(width:4,source:opcode(15)),(width:4,source:fixed_bits(0)),(width:8,source:trap_vect8)] ) ] ),
                    ( name: "RTI", description: "Returns from an interrupt.", notes: Some("Must be executed in Supervisor mode."), formats: [ ( mode_selection_name: "Standard", syntax: "RTI", description: "Restores PC and PSR from the supervisor stack.", operands: [], binary_layout: "Layout: 1000|000000000000", binary_segments: [(width:4,source:opcode(8)),(width:12,source:fixed_bits(0))] ) ] ),
                ]
            )
        ]
    ),

    // This section provides quick-reference material and code examples.
    cheatsheet: (
        title: "LC-3 Cheatsheet & Examples",
        description: "A quick reference for common assembly patterns and full programs.",
        categories: [
            ( title: "Directives", items: [ ".ORIG x3000       ; Program starting address", ".FILL #10         ; Insert a 16-bit value", ".BLKW 5           ; Reserve 5 words of memory", ".STRINGZ \"Text\"  ; Create a null-terminated string", ".END              ; End of program" ] ),
            ( title: "System Calls (TRAPs)", items: [ "GETC              ; (TRAP x20) Read a char into R0", "OUT               ; (TRAP x21) Write char from R0", "PUTS              ; (TRAP x22) Write string starting at R0", "IN                ; (TRAP x23) Prompt and read char into R0", "HALT              ; (TRAP x25) Stop the program" ] ),
            ( title: "Number Formats", items: ["#10               ; Decimal", "x10A2             ; Hexadecimal", "LABEL             ; Label reference"] ),
        ],
        examples: [
            ( title: "Hello World", code: r#".ORIG x3000
LEA R0, MESSAGE
PUTS
HALT
MESSAGE: .STRINGZ "Hello, World!"
.END"# ),
            ( title: "Counter Loop", code: r#".ORIG x3000
AND R2, R2, #0      ; R2 is our counter
LD R1, TEN          ; Load -10 for comparison
LOOP:   
    ADD R0, R2, #48 ; Convert number to ASCII '0'
    OUT             ; Print digit
    ADD R2, R2, #1  ; Increment counter
    ADD R3, R2, R1  ; R3 = R2 - 10
    BRnp LOOP       ; Loop if not yet 10
HALT
TEN: .FILL #-10
.END"# ),
            ( title: "Subroutine Example", code: r#".ORIG x3000
JSR SUBROUTINE      ; Call subroutine
HALT                ; End program

SUBROUTINE:
    ST R7, SAVE_R7      ; Save return address
    LEA R0, MESSAGE     ; Load message
    PUTS                ; Print it
    LD R7, SAVE_R7      ; Restore return address
    RET                 ; Return from subroutine

SAVE_R7: .BLKW 1
MESSAGE: .STRINGZ "Called from subroutine!"
.END"# ),
            ( title: "Array Sum", code: r#".ORIG x3000
AND R0, R0, #0      ; Clear R0 (sum)
LEA R1, ARRAY       ; R1 points to start of array
LD R2, COUNT        ; R2 holds counter
LOOP:
    LDR R3, R1, #0      ; Load array element
    ADD R0, R0, R3      ; Add to sum
    ADD R1, R1, #1      ; Point to next element
    ADD R2, R2, #-1     ; Decrement counter
    BRp LOOP            ; Repeat if more elements
HALT
COUNT: .FILL #5
ARRAY: .FILL #10, .FILL #20, .FILL #30, .FILL #40, .FILL #50
.END"# ),
        ],
    ),
)
